From 3d6afca975e5c54d458974ca2e9ada3df209587c Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Wed, 20 May 2015 13:22:45 +1000
Subject: [PATCH xf86-input-libinput] Only init abs axes if we don't have
 acceleration

A lot of devices (mainly MS input devices) have abs axes on top of the
relative axes. Those axes are usually mute but with the current code we set up
absolute axes for those devices. Relative events are then scaled by the server
which makes the device appear slow.

As an immediate fix always prefer relative axes and only set up absolute axes
if the device has a calibration matrix but no pointer acceleration.
This may mess up other devices where the relative axes are dead, we'll deal
with this when it comes.

https://bugs.freedesktop.org/show_bug.cgi?id=90322

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
---
 src/libinput.c | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/src/libinput.c b/src/libinput.c
index 3e54529..c8669fc 100644
--- a/src/libinput.c
+++ b/src/libinput.c
@@ -85,6 +85,8 @@ struct xf86libinput {
 		double y_remainder;
 	} scale;
 
+	BOOL has_abs;
+
 	ValuatorMask *valuators;
 
 	struct options {
@@ -526,6 +528,8 @@ xf86libinput_init_pointer_absolute(InputInfoPtr pInfo)
 	SetScrollValuator(dev, 2, SCROLL_TYPE_HORIZONTAL, driver_data->scroll.hdist, 0);
 	SetScrollValuator(dev, 3, SCROLL_TYPE_VERTICAL, driver_data->scroll.vdist, 0);
 
+	driver_data->has_abs = TRUE;
+
 	return Success;
 }
 static void
@@ -636,7 +640,8 @@ xf86libinput_init(DeviceIntPtr dev)
 	if (libinput_device_has_capability(device, LIBINPUT_DEVICE_CAP_KEYBOARD))
 		xf86libinput_init_keyboard(pInfo);
 	if (libinput_device_has_capability(device, LIBINPUT_DEVICE_CAP_POINTER)) {
-		if (libinput_device_config_calibration_has_matrix(device))
+		if (libinput_device_config_calibration_has_matrix(device) &&
+		    !libinput_device_config_accel_is_available(device))
 			xf86libinput_init_pointer_absolute(pInfo);
 		else
 			xf86libinput_init_pointer(pInfo);
@@ -709,6 +714,13 @@ xf86libinput_handle_absmotion(InputInfoPtr pInfo, struct libinput_event_pointer
 	ValuatorMask *mask = driver_data->valuators;
 	double x, y;
 
+	if (!driver_data->has_abs) {
+		xf86IDrvMsg(pInfo, X_ERROR,
+			    "Discarding absolute event from relative device. "
+			    "Please file a bug\n");
+		return;
+	}
+
 	x = libinput_event_pointer_get_absolute_x_transformed(event, TOUCH_AXIS_MAX);
 	y = libinput_event_pointer_get_absolute_y_transformed(event, TOUCH_AXIS_MAX);
 
-- 
2.3.5

